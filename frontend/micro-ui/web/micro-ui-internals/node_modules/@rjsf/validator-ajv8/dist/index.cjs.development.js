'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@rjsf/utils');
var createAjvInstance = require('./createAjvInstance-0cd8cfba.js');
var get = require('lodash/get');
var isEqual = require('lodash/isEqual');
require('ajv');
require('ajv-formats');
require('lodash/isObject');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var get__default = /*#__PURE__*/_interopDefaultLegacy(get);
var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);

var _excluded = ["instancePath", "keyword", "params", "schemaPath", "parentSchema"];
/** Transforming the error output from ajv to format used by @rjsf/utils.
 * At some point, components should be updated to support ajv.
 *
 * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`
 * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
 */
function transformRJSFValidationErrors(errors, uiSchema) {
  if (errors === void 0) {
    errors = [];
  }
  return errors.map(function (e) {
    var instancePath = e.instancePath,
      keyword = e.keyword,
      params = e.params,
      schemaPath = e.schemaPath,
      parentSchema = e.parentSchema,
      rest = createAjvInstance._objectWithoutPropertiesLoose(e, _excluded);
    var _rest$message = rest.message,
      message = _rest$message === void 0 ? '' : _rest$message;
    var property = instancePath.replace(/\//g, '.');
    var stack = (property + " " + message).trim();
    if ('missingProperty' in params) {
      property = property ? property + "." + params.missingProperty : params.missingProperty;
      var currentProperty = params.missingProperty;
      var uiSchemaTitle = utils.getUiOptions(get__default["default"](uiSchema, "" + property.replace(/^\./, ''))).title;
      if (uiSchemaTitle) {
        message = message.replace(currentProperty, uiSchemaTitle);
      } else {
        var parentSchemaTitle = get__default["default"](parentSchema, [utils.PROPERTIES_KEY, currentProperty, 'title']);
        if (parentSchemaTitle) {
          message = message.replace(currentProperty, parentSchemaTitle);
        }
      }
      stack = message;
    } else {
      var _uiSchemaTitle = utils.getUiOptions(get__default["default"](uiSchema, "" + property.replace(/^\./, ''))).title;
      if (_uiSchemaTitle) {
        stack = ("'" + _uiSchemaTitle + "' " + message).trim();
      } else {
        var _parentSchemaTitle = parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.title;
        if (_parentSchemaTitle) {
          stack = ("'" + _parentSchemaTitle + "' " + message).trim();
        }
      }
    }
    // put data in expected format
    return {
      name: keyword,
      property: property,
      message: message,
      params: params,
      stack: stack,
      schemaPath: schemaPath
    };
  });
}
/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
 * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
 * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
 * transform them in what ever way it chooses.
 *
 * @param validator - The `ValidatorType` implementation used for the `getDefaultFormState()` call
 * @param rawErrors - The list of raw `ErrorObject`s to process
 * @param formData - The form data to validate
 * @param schema - The schema against which to validate the form data
 * @param [customValidate] - An optional function that is used to perform custom validation
 * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
 * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
 */
function processRawValidationErrors(validator, rawErrors, formData, schema, customValidate, transformErrors, uiSchema) {
  var invalidSchemaError = rawErrors.validationError;
  var errors = transformRJSFValidationErrors(rawErrors.errors, uiSchema);
  if (invalidSchemaError) {
    errors = [].concat(errors, [{
      stack: invalidSchemaError.message
    }]);
  }
  if (typeof transformErrors === 'function') {
    errors = transformErrors(errors, uiSchema);
  }
  var errorSchema = utils.toErrorSchema(errors);
  if (invalidSchemaError) {
    errorSchema = createAjvInstance._extends({}, errorSchema, {
      $schema: {
        __errors: [invalidSchemaError.message]
      }
    });
  }
  if (typeof customValidate !== 'function') {
    return {
      errors: errors,
      errorSchema: errorSchema
    };
  }
  // Include form data with undefined values, which is required for custom validation.
  var newFormData = utils.getDefaultFormState(validator, schema, formData, schema, true);
  var errorHandler = customValidate(newFormData, utils.createErrorHandler(newFormData), uiSchema);
  var userErrorSchema = utils.unwrapErrorHandler(errorHandler);
  return utils.validationDataMerge({
    errors: errors,
    errorSchema: errorSchema
  }, userErrorSchema);
}

/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.
 */
var AJV8Validator = /*#__PURE__*/function () {
  /** Constructs an `AJV8Validator` instance using the `options`
   *
   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance
   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
   */
  function AJV8Validator(options, localizer) {
    /** The AJV instance to use for all validations
     *
     * @private
     */
    this.ajv = void 0;
    /** The Localizer function to use for localizing Ajv errors
     *
     * @private
     */
    this.localizer = void 0;
    var additionalMetaSchemas = options.additionalMetaSchemas,
      customFormats = options.customFormats,
      ajvOptionsOverrides = options.ajvOptionsOverrides,
      ajvFormatOptions = options.ajvFormatOptions,
      AjvClass = options.AjvClass;
    this.ajv = createAjvInstance.createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);
    this.localizer = localizer;
  }
  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`
   *
   * @param errorSchema - The `ErrorSchema` instance to convert
   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified
   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in
   *        the next major release.
   */
  var _proto = AJV8Validator.prototype;
  _proto.toErrorList = function toErrorList(errorSchema, fieldPath) {
    if (fieldPath === void 0) {
      fieldPath = [];
    }
    return utils.toErrorList(errorSchema, fieldPath);
  }
  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
   * by the playground. Returns the `errors` from the validation
   *
   * @param schema - The schema against which to validate the form data   * @param schema
   * @param formData - The form data to validate
   */;
  _proto.rawValidation = function rawValidation(schema, formData) {
    var compilationError = undefined;
    var compiledValidator;
    if (schema[utils.ID_KEY]) {
      compiledValidator = this.ajv.getSchema(schema[utils.ID_KEY]);
    }
    try {
      if (compiledValidator === undefined) {
        compiledValidator = this.ajv.compile(schema);
      }
      compiledValidator(formData);
    } catch (err) {
      compilationError = err;
    }
    var errors;
    if (compiledValidator) {
      if (typeof this.localizer === 'function') {
        this.localizer(compiledValidator.errors);
      }
      errors = compiledValidator.errors || undefined;
      // Clear errors to prevent persistent errors, see #1104
      compiledValidator.errors = null;
    }
    return {
      errors: errors,
      validationError: compilationError
    };
  }
  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
   * transform them in what ever way it chooses.
   *
   * @param formData - The form data to validate
   * @param schema - The schema against which to validate the form data
   * @param [customValidate] - An optional function that is used to perform custom validation
   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
   */;
  _proto.validateFormData = function validateFormData(formData, schema, customValidate, transformErrors, uiSchema) {
    var rawErrors = this.rawValidation(schema, formData);
    return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);
  }
  /** Validates data against a schema, returning true if the data is valid, or
   * false otherwise. If the schema is invalid, then this function will return
   * false.
   *
   * @param schema - The schema against which to validate the form data
   * @param formData - The form data to validate
   * @param rootSchema - The root schema used to provide $ref resolutions
   */;
  _proto.isValid = function isValid(schema, formData, rootSchema) {
    var _rootSchema$ID_KEY;
    var rootSchemaId = (_rootSchema$ID_KEY = rootSchema[utils.ID_KEY]) != null ? _rootSchema$ID_KEY : utils.ROOT_SCHEMA_PREFIX;
    try {
      var _schemaWithIdRefPrefi;
      // add the rootSchema ROOT_SCHEMA_PREFIX as id.
      // then rewrite the schema ref's to point to the rootSchema
      // this accounts for the case where schema have references to models
      // that lives in the rootSchema but not in the schema in question.
      if (this.ajv.getSchema(rootSchemaId) === undefined) {
        this.ajv.addSchema(rootSchema, rootSchemaId);
      }
      var schemaWithIdRefPrefix = utils.withIdRefPrefix(schema);
      var schemaId = (_schemaWithIdRefPrefi = schemaWithIdRefPrefix[utils.ID_KEY]) != null ? _schemaWithIdRefPrefi : utils.hashForSchema(schemaWithIdRefPrefix);
      var compiledValidator;
      compiledValidator = this.ajv.getSchema(schemaId);
      if (compiledValidator === undefined) {
        // Add schema by an explicit ID so it can be fetched later
        // Fall back to using compile if necessary
        // https://ajv.js.org/guide/managing-schemas.html#pre-adding-all-schemas-vs-adding-on-demand
        compiledValidator = this.ajv.addSchema(schemaWithIdRefPrefix, schemaId).getSchema(schemaId) || this.ajv.compile(schemaWithIdRefPrefix);
      }
      var result = compiledValidator(formData);
      return result;
    } catch (e) {
      console.warn('Error encountered compiling schema:', e);
      return false;
    } finally {
      // TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.
      // make sure we remove the rootSchema from the global ajv instance
      this.ajv.removeSchema(rootSchemaId);
    }
  };
  return AJV8Validator;
}();

/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if
 * provided. If a `localizer` is provided, it is used to translate the messages generated by the underlying AJV
 * validation.
 *
 * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance
 * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
 * @returns - The custom validator implementation resulting from the set of parameters provided
 */
function customizeValidator(options, localizer) {
  if (options === void 0) {
    options = {};
  }
  return new AJV8Validator(options, localizer);
}

/** `ValidatorType` implementation that uses an AJV 8 precompiled validator as created by the
 * `compileSchemaValidators()` function provided by the `@rjsf/validator-ajv8` library.
 */
var AJV8PrecompiledValidator = /*#__PURE__*/function () {
  /** Constructs an `AJV8PrecompiledValidator` instance using the `validateFns` and `rootSchema`
   *
   * @param validateFns - The map of the validation functions that are generated by the `schemaCompile()` function
   * @param rootSchema - The root schema that was used with the `compileSchema()` function
   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
   * @throws - Error when the base schema of the precompiled validator does not have a matching validator function
   */
  function AJV8PrecompiledValidator(validateFns, rootSchema, localizer) {
    /** The root schema object used to construct this validator
     *
     * @private
     */
    this.rootSchema = void 0;
    /** The root schema resolved top level refs
     *
     * @private
     */
    this.resolvedRootSchema = void 0;
    /** The `ValidatorFunctions` map used to construct this validator
     *
     * @private
     */
    this.validateFns = void 0;
    /** The main validator function associated with the base schema in the `precompiledValidator`
     *
     * @private
     */
    this.mainValidator = void 0;
    /** The Localizer function to use for localizing Ajv errors
     *
     * @private
     */
    this.localizer = void 0;
    this.rootSchema = rootSchema;
    this.validateFns = validateFns;
    this.localizer = localizer;
    this.mainValidator = this.getValidator(rootSchema);
    this.resolvedRootSchema = utils.retrieveSchema(this, rootSchema, rootSchema);
  }
  /** Returns the precompiled validator associated with the given `schema` from the map of precompiled validator
   * functions.
   *
   * @param schema - The schema for which a precompiled validator function is desired
   * @returns - The precompiled validator function associated with this schema
   */
  var _proto = AJV8PrecompiledValidator.prototype;
  _proto.getValidator = function getValidator(schema) {
    var key = get__default["default"](schema, utils.ID_KEY) || utils.hashForSchema(schema);
    var validator = this.validateFns[key];
    if (!validator) {
      throw new Error("No precompiled validator function was found for the given schema for \"" + key + "\"");
    }
    return validator;
  }
  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`
   *
   * @param errorSchema - The `ErrorSchema` instance to convert
   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified
   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in
   *        the next major release.
   */;
  _proto.toErrorList = function toErrorList(errorSchema, fieldPath) {
    if (fieldPath === void 0) {
      fieldPath = [];
    }
    return utils.toErrorList(errorSchema, fieldPath);
  }
  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
   * by the playground. Returns the `errors` from the validation
   *
   * @param schema - The schema against which to validate the form data   * @param schema
   * @param formData - The form data to validate
   * @throws - Error when the schema provided does not match the base schema of the precompiled validator
   */;
  _proto.rawValidation = function rawValidation(schema, formData) {
    if (!isEqual__default["default"](schema, this.resolvedRootSchema)) {
      throw new Error('The schema associated with the precompiled schema differs from the schema provided for validation');
    }
    this.mainValidator(formData);
    if (typeof this.localizer === 'function') {
      this.localizer(this.mainValidator.errors);
    }
    var errors = this.mainValidator.errors || undefined;
    // Clear errors to prevent persistent errors, see #1104
    this.mainValidator.errors = null;
    return {
      errors: errors
    };
  }
  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
   * transform them in what ever way it chooses.
   *
   * @param formData - The form data to validate
   * @param schema - The schema against which to validate the form data
   * @param [customValidate] - An optional function that is used to perform custom validation
   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
   */;
  _proto.validateFormData = function validateFormData(formData, schema, customValidate, transformErrors, uiSchema) {
    var rawErrors = this.rawValidation(schema, formData);
    return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);
  }
  /** Validates data against a schema, returning true if the data is valid, or false otherwise. If the schema is
   * invalid, then this function will return false.
   *
   * @param schema - The schema against which to validate the form data
   * @param formData - The form data to validate
   * @param rootSchema - The root schema used to provide $ref resolutions
   * @returns - true if the formData validates against the schema, false otherwise
   * @throws - Error when the schema provided does not match the base schema of the precompiled validator OR if there
   *        isn't a precompiled validator function associated with the schema
   */;
  _proto.isValid = function isValid(schema, formData, rootSchema) {
    if (!isEqual__default["default"](rootSchema, this.rootSchema)) {
      throw new Error('The schema associated with the precompiled validator differs from the rootSchema provided for validation');
    }
    if (get__default["default"](schema, utils.ID_KEY) === utils.JUNK_OPTION_ID) {
      return false;
    }
    var validator = this.getValidator(schema);
    return validator(formData);
  };
  return AJV8PrecompiledValidator;
}();

/** Creates and returns a `ValidatorType` interface that is implemented with a precompiled validator. If a `localizer`
 * is provided, it is used to translate the messages generated by the underlying AJV validation.
 *
 * NOTE: The `validateFns` parameter is an object obtained by importing from a precompiled validation file created via
 * the `compileSchemaValidators()` function.
 *
 * @param validateFns - The map of the validation functions that are created by the `compileSchemaValidators()` function
 * @param rootSchema - The root schema that was used with the `compileSchemaValidators()` function
 * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
 * @returns - The precompiled validator implementation resulting from the set of parameters provided
 */
function createPrecompiledValidator(validateFns, rootSchema, localizer) {
  return new AJV8PrecompiledValidator(validateFns, rootSchema, localizer);
}

var index = /*#__PURE__*/customizeValidator();

exports.createPrecompiledValidator = createPrecompiledValidator;
exports.customizeValidator = customizeValidator;
exports["default"] = index;
//# sourceMappingURL=index.cjs.development.js.map
