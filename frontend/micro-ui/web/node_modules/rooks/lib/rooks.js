(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.rooks = {}, global.React));
}(this, (function (exports, react) { 'use strict';

  var config = {
      attributes: true,
      characterData: true,
      subtree: true,
      childList: true
  };
  /**
   *
   * useMutationObserver hook
   *
   * Returns a mutation observer for a React Ref and fires a callback
   *
   * @param {MutableRefObject<HTMLElement | null>} ref React ref on which mutations are to be observed
   * @param {MutationCallback} callback Function that needs to be fired on mutation
   * @param {MutationObserverInit} options
   */
  function useMutationObserver(ref, callback, options = config) {
      react.useEffect(() => {
          // Create an observer instance linked to the callback function
          if (ref.current) {
              const observer = new MutationObserver(callback);
              // Start observing the target node for configured mutations
              observer.observe(ref.current, options);
              return () => {
                  observer.disconnect();
              };
          }
      }, [callback, options]);
  }

  /**
   * useDidMount hook
   * Calls a function on mount
   *
   * @param {function} callback Callback function to be called on mount
   */
  function useDidMount(callback) {
      react.useEffect(() => {
          if (typeof callback === "function") {
              callback();
          }
      }, []);
  }

  /**
   * @param element HTML element whose boundingclientrect is needed
   * @return ClientRect
   */
  function getBoundingClientRect(element) {
      return element.getBoundingClientRect();
  }
  /**
   * useBoundingclientRect hook
   * @param ref The React ref whose ClientRect is needed
   * @return ClientRect
   */
  function useBoundingclientrect(ref) {
      const [value, setValue] = react.useState(null);
      const update = react.useCallback(() => {
          setValue(ref.current ? getBoundingClientRect(ref.current) : null);
      }, []);
      useDidMount(() => {
          update();
      });
      useMutationObserver(ref, update);
      return value;
  }

  var config$1 = {
      attributes: true,
      characterData: true,
      subtree: true,
      childList: true
  };
  /**
   *
   * useMutationObserverRef hook
   *
   * Returns a mutation observer for a React Ref and fires a callback
   *
   * @param {MutationCallback} callback Function that needs to be fired on mutation
   * @param {MutationObserverInit} options
   */
  function useMutationObserverRef(callback, options = config$1) {
      const [node, setNode] = react.useState(null);
      react.useEffect(() => {
          // Create an observer instance linked to the callback function
          if (node) {
              const observer = new MutationObserver(callback);
              // Start observing the target node for configured mutations
              observer.observe(node, options);
              return () => {
                  observer.disconnect();
              };
          }
      }, [node, callback, options]);
      const ref = react.useCallback((node) => {
          setNode(node);
      }, []);
      return [ref];
  }

  /**
   * Credit to material-ui for this snippet
   */
  function setRef(ref, value) {
      if (typeof ref === "function") {
          ref(value);
      }
      else if (ref) {
          ref.current = value;
      }
  }
  /**
   * useForkRef
   * Joins refs together and returns a combination of the two as a new ref
   * @param refA
   * @param refB
   */
  function useForkRef(refA, refB) {
      /**
       * This will create a new function if the ref props change and are defined.
       * This means react will call the old forkRef with `null` and the new forkRef
       * with the ref. Cleanup naturally emerges from this behavior
       */
      return react.useMemo(() => {
          if (refA == null && refB == null) {
              return null;
          }
          return (refValue) => {
              setRef(refA, refValue);
              setRef(refB, refValue);
          };
      }, [refA, refB]);
  }

  /**
   * @param element HTML element whose boundingclientrect is needed
   * @return ClientRect
   */
  function getBoundingClientRect$1(element) {
      return element.getBoundingClientRect();
  }
  /**
   * useBoundingclientrectRef hook
   * @return [CallbackRef | null, ClientRect | DOMRect | null, () => void]
   */
  function useBoundingclientrectRef() {
      const [value, setValue] = react.useState(null);
      const [node, setNode] = react.useState(null);
      const update = react.useCallback(() => {
          setValue(node ? getBoundingClientRect$1(node) : null);
      }, [node]);
      react.useEffect(() => {
          update();
      }, [node]);
      const ref = react.useCallback((node) => {
          setNode(node);
      }, []);
      const [mutationObserverRef] = useMutationObserverRef(update);
      const forkedRef = useForkRef(ref, mutationObserverRef);
      return [forkedRef, value, update];
  }

  // See also: https://overreacted.io/making-setinterval-declarative-with-react-hooks/
  /**
   *
   * useInterval hook
   *
   * Declaratively creates a setInterval to run a callback after a fixed
   * amount of time
   *
   *@param {funnction} callback - Callback to be fired
   *@param {number} intervalId - Interval duration in milliseconds after which the callback is to be fired
   *@param {boolean} startImmediate - Whether the interval should start immediately on initialise
   *@return {IntervalHandler}
   */
  function useInterval(callback, intervalDuration, startImmediate = false) {
      const internalIdRef = react.useRef(null);
      const [isRunning, setIsRunning] = react.useState(startImmediate);
      const savedCallback = react.useRef();
      function start() {
          if (!isRunning) {
              setIsRunning(true);
          }
      }
      function stop() {
          if (isRunning) {
              setIsRunning(false);
          }
      }
      // Remember the latest callback.
      react.useEffect(() => {
          savedCallback.current = callback;
      });
      // Set up the interval.
      react.useEffect(() => {
          function tick() {
              savedCallback.current && savedCallback.current();
          }
          if (intervalDuration !== null && isRunning) {
              let id = setInterval(tick, intervalDuration);
              internalIdRef.current = id;
              return () => {
                  internalIdRef.current = null;
                  clearInterval(id);
              };
          }
      }, [intervalDuration, isRunning]);
      let handler;
      handler = [start, stop, internalIdRef.current];
      handler.start = start;
      handler.stop = stop;
      handler.intervalId = internalIdRef.current;
      return handler;
  }

  /**
   *
   * useCountdown
   * Easy way to countdown until a given endtime in intervals
   * @param endTime Time to countdown
   * @param options  Countdown options
   */
  function useCountdown(endTime, options = {}) {
      const { interval = 1000, onDown, onEnd } = options;
      const [time, setTime] = react.useState(() => new Date());
      const restTime = endTime.getTime() - time.getTime();
      const count = restTime > 0 ? Math.ceil(restTime / interval) : 0;
      useInterval(onTick, count ? interval : null, true);
      return count;
      function onTick() {
          const newTime = new Date();
          if (newTime > endTime) {
              if (onEnd) {
                  onEnd(newTime);
              }
              setTime(endTime);
              return;
          }
          if (onDown) {
              onDown(restTime, newTime);
          }
          setTime(newTime);
      }
  }

  /**
   *
   * @typedef handler
   * @type {Object}
   * @property {number} value The value of the counter
   * @property {function}  increment Increment counter value by 1
   * @property {function} decrement Decrement counter value by 1
   * @property {function} incrementBy Increment counter by incrAmount
   * @property {function} decrementBy Decrement counter by decrAmount
   * @property {function} reset Reset counter to initialValue
   */
  /**
   * Counter hook
   * @param {number} initialValue The initial value of the counter
   * @returns {handler} A handler to interact with the counter
   */
  function useCounter(initialValue) {
      const [counter, setCounter] = react.useState(initialValue);
      /**
       * Increment counter by an amount
       * @param {number} incrAmount
       */
      function incrementBy(incrAmount) {
          setCounter(counter + incrAmount);
      }
      /**
       *
       * Decrement counter by an amount
       * @param {*} decrAmount
       */
      function decrementBy(decrAmount) {
          incrementBy(-decrAmount);
      }
      /**
       * Increment counter by 1
       */
      function increment() {
          incrementBy(1);
      }
      /**
       * Decrement counter by 1
       */
      function decrement() {
          incrementBy(-1);
      }
      /**
       * Reset counter to initial value
       */
      function reset() {
          setCounter(initialValue);
      }
      return {
          value: counter,
          increment,
          decrement,
          incrementBy,
          decrementBy,
          reset
      };
  }

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString = objectProto.toString;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max,
      nativeMin = Math.min;

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root.Date.now();
  };

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          result = wait - timeSinceLastCall;

      return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && objectToString.call(value) == symbolTag);
  }

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  var lodash_debounce = debounce;

  /**
   * Debounce hook
   * @param {function} callback The callback to debounce
   * @param {number} wait The duration to debounce
   * @returns {function} The debounced callback
   */
  function useDebounce(callback, wait, options) {
      function createDebouncedCallback(fn) {
          return lodash_debounce(fn, wait, options);
      }
      const callbackRef = react.useRef(callback);
      const debouncedCallbackRef = react.useRef(createDebouncedCallback(callback));
      react.useEffect(() => {
          callbackRef.current = callback;
      });
      react.useEffect(() => {
          debouncedCallbackRef.current = createDebouncedCallback((...args) => {
              callbackRef.current(...args);
          });
      }, [wait, options]);
      return debouncedCallbackRef.current;
  }

  /**
   *  useDidUpdate hook
   *
   *  Fires a callback on component update
   *  Can take in a list of conditions to fire callback when one of the
   *  conditions changes
   *
   * @param {function} callback The callback to be called on update
   * @param {Array} conditions The list of variables which trigger update when they are changed
   * @return {undefined}
   */
  function useDidUpdate(callback, conditions) {
      const hasMountedRef = react.useRef(false);
      if (typeof conditions !== "undefined" && !Array.isArray(conditions)) {
          conditions = [conditions];
      }
      else if (Array.isArray(conditions) && conditions.length === 0) {
          console.warn("Using [] as the second argument makes useDidUpdate a noop. The second argument should either be `undefined` or an array of length greater than 0.");
      }
      react.useEffect(() => {
          if (hasMountedRef.current) {
              callback();
          }
          else {
              hasMountedRef.current = true;
          }
      }, conditions);
  }

  /**
   * useIsomorphicEffect
   * Resolves to useEffect when "window" is not in scope and useLayout effect in the browser
   * @param {function} callback Callback function to be called on mount
   */
  const useIsomorphicEffect = typeof window === "undefined" ? react.useEffect : react.useLayoutEffect;

  /**
   * useFreshRef
   * @param value The value which needs to be fresh at all times. Probably
   * best used with functions
   * @param preferLayoutEffect Should the value be updated using a layout effect
   * or a passive effect. Defaults to false.
   * @returns A ref containing the fresh value
   */
  function useFreshRef(value, preferLayoutEffect = false) {
      const useEffectToUse = preferLayoutEffect ? useIsomorphicEffect : react.useEffect;
      const ref = react.useRef(value);
      useEffectToUse(() => {
          ref.current = value;
      });
      return ref;
  }

  function useFreshTick(callback) {
      const freshRef = useFreshRef(callback);
      function tick(...args) {
          if (freshRef && typeof freshRef.current === "function") {
              freshRef.current(...args);
          }
      }
      return tick;
  }

  /**
   *  useGlobalObjectEventListener hook
   *
   *  A react hook to an event listener to a global object
   *
   * @param {Window|Document} globalObject The global object to add event onto
   * @param {string} eventName The event to track
   * @param {function} callback The callback to be called on event
   * @param {object} conditions The options to be passed to the event listener
   * @param {boolean} when Should the event listener be active
   * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
   * @return {undefined}
   */
  function useGlobalObjectEventListener(globalObject, eventName, callback, listenerOptions = {}, when = true, isLayoutEffect = false) {
      const freshCallback = useFreshTick(callback);
      const { capture, passive, once } = listenerOptions;
      const useEffectToRun = isLayoutEffect ? useIsomorphicEffect : react.useEffect;
      useEffectToRun(() => {
          if (typeof globalObject !== "undefined" && globalObject.addEventListener && when) {
              globalObject.addEventListener(eventName, freshCallback, listenerOptions);
              return () => {
                  globalObject.removeEventListener(eventName, freshCallback, listenerOptions);
              };
          }
      }, [eventName, capture, passive, once]);
  }

  /**
   *  useDocumentEventListener hook
   *
   *  A react hook to an event listener to the document
   *
   * @param {string} eventName The event to track
   * @param {function} callback The callback to be called on event
   * @param {object} conditions The options to be passed to the event listener
   * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
   * @return {undefined}
   */
  function useDocumentEventListener(eventName, callback, listenerOptions = {}, isLayoutEffect = false) {
      if (typeof document !== "undefined") {
          useGlobalObjectEventListener(document, eventName, callback, listenerOptions, true, isLayoutEffect);
      }
      else {
          console.warn("useDocumentEventListener can't attach an event listener as document is undefined.");
      }
  }

  /**
   * useEffectOnceWhen hook
   *
   * It fires a callback once when a condition is true or become true.
   * Fires the callback at most one time.
   *
   * @param callback The callback to fire
   * @param when The condition which needs to be true
   */
  function useEffectOnceWhen(callback, when = true) {
      const hasRunOnceRef = react.useRef(false);
      const callbackRef = react.useRef(callback);
      react.useEffect(() => {
          callbackRef.current = callback;
      });
      react.useEffect(() => {
          if (when && !hasRunOnceRef.current) {
              callbackRef.current();
              hasRunOnceRef.current = true;
          }
      }, [when]);
  }

  /**
   * useRefElement hook for React
   * Helps bridge gap between callback ref and state
   * Manages the element called with callback ref api using state variable
   */
  function useRefElement() {
      const [refElement, setRefElement] = react.useState(null);
      const ref = react.useCallback((refElement) => {
          setRefElement(refElement);
      }, []);
      return [ref, refElement];
  }

  /**
   *  useEventListenerRef hook
   *
   *  A react hook to an event listener to an element
   *  Returns a ref
   *
   * @param {string} eventName The event to track
   * @param {function} callback The callback to be called on event
   * @param {object} conditions The options to be passed to the event listener
   * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
   * @return {function} A callback ref that can be used as ref prop
   */
  function useEventListenerRef(eventName, callback, listenerOptions = {}, isLayoutEffect = false) {
      const [ref, element] = useRefElement();
      const freshCallback = useFreshTick(callback);
      const { capture, passive, once } = listenerOptions;
      const useEffectToRun = isLayoutEffect ? useIsomorphicEffect : react.useEffect;
      useEffectToRun(() => {
          if (!(element && element.addEventListener)) {
              return;
          }
          element.addEventListener(eventName, freshCallback, listenerOptions);
          return () => {
              element.removeEventListener(eventName, freshCallback, listenerOptions);
          };
      }, [element, eventName, capture, passive, once]);
      return ref;
  }

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  const __DEV__ = process.env.NODE_ENV !== 'production';
  let warning = function () { };
  if (__DEV__) {
      const printWarning = function printWarning(...actualMessage) {
          const message = `Warning: ${actualMessage}`;
          if (typeof console !== 'undefined') {
              console.error(message);
          }
          try {
              // --- Welcome to debugging React ---
              // This error was thrown as a convenience so that you can use this stack
              // to find the callsite that caused this warning to fire.
              throw new Error(message);
          }
          catch (x) { }
      };
      warning = function (condition, actualMessage) {
          if (!condition) {
              printWarning(actualMessage);
          }
      };
  }

  const getFullscreenControls = () => {
      const fnMap = [
          [
              'requestFullscreen',
              'exitFullscreen',
              'fullscreenElement',
              'fullscreenEnabled',
              'fullscreenchange',
              'fullscreenerror',
          ],
          // New WebKit
          [
              'webkitRequestFullscreen',
              'webkitExitFullscreen',
              'webkitFullscreenElement',
              'webkitFullscreenEnabled',
              'webkitfullscreenchange',
              'webkitfullscreenerror',
          ],
          // Old WebKit
          [
              'webkitRequestFullScreen',
              'webkitCancelFullScreen',
              'webkitCurrentFullScreenElement',
              'webkitCancelFullScreen',
              'webkitfullscreenchange',
              'webkitfullscreenerror',
          ],
          [
              'mozRequestFullScreen',
              'mozCancelFullScreen',
              'mozFullScreenElement',
              'mozFullScreenEnabled',
              'mozfullscreenchange',
              'mozfullscreenerror',
          ],
          [
              'msRequestFullscreen',
              'msExitFullscreen',
              'msFullscreenElement',
              'msFullscreenEnabled',
              'MSFullscreenChange',
              'MSFullscreenError',
          ],
      ];
      const ret = {};
      fnMap.forEach((fnSet) => {
          if (fnSet && fnSet[1] in document) {
              fnSet.forEach((_fn, i) => {
                  ret[fnMap[0][i]] = fnSet[i];
              });
          }
      });
      return ret;
  };
  const noop = () => { };
  const defaultValue = {
      isEnabled: false,
      toggle: noop,
      onChange: noop,
      onError: noop,
      request: noop,
      exit: noop,
      isFullscreen: false,
      element: undefined,
  };
  function warnDeprecatedOnChangeAndOnErrorUsage() {
      warning(false, `Using onChange and onError from the return value is deprecated and 
    will be removed in the next major version. 
    Please use it with arguments instead. 
    For eg: useFullscreen({onChange: function() {}, onError: function(){}})
  `);
  }
  /**
   * useFullscreen
   * A hook that helps make the document fullscreen
   */
  function useFullscreen(options = {}) {
      if (typeof window === 'undefined') {
          return defaultValue;
      }
      const { onChange: onChangeArg, onError: onErrorArg } = options;
      const fullscreenControls = getFullscreenControls();
      const [isFullscreen, setIsFullscreen] = react.useState(Boolean(document[fullscreenControls.fullscreenElement]));
      const [element, setElement] = react.useState(document[fullscreenControls.fullscreenElement]);
      const request = react.useCallback((element) => __awaiter(this, void 0, void 0, function* () {
          try {
              const finalElem = element || document.documentElement;
              return yield finalElem[fullscreenControls.requestFullscreen]();
          }
          catch (err) {
              console.log(err);
          }
      }), []);
      const exit = react.useCallback(() => __awaiter(this, void 0, void 0, function* () {
          if (element) {
              try {
                  return yield document[fullscreenControls.exitFullscreen]();
              }
              catch (err) {
                  console.warn(err);
              }
          }
      }), [element]);
      const toggle = react.useCallback((newElement) => Boolean(element) ? exit() : newElement ? request(newElement) : null, [element]);
      const onChangeDeprecatedHandlerRef = react.useRef(noop);
      const onErrorDeprecatedHandlerRef = react.useRef(noop);
      // Hack to not break it for everyone
      // Honestly these two functions are tragedy and must be removed in v5
      const onChangeDeprecated = react.useCallback((callback) => {
          warnDeprecatedOnChangeAndOnErrorUsage();
          return (onChangeDeprecatedHandlerRef.current = callback);
      }, []);
      const onErrorDeprecated = react.useCallback((callback) => {
          warnDeprecatedOnChangeAndOnErrorUsage();
          return (onErrorDeprecatedHandlerRef.current = callback);
      }, []);
      useDocumentEventListener(fullscreenControls.fullscreenchange, function (event) {
          var _a;
          const currentFullscreenElement = document[fullscreenControls.fullscreenElement];
          const isOpen = Boolean(currentFullscreenElement);
          if (isOpen) {
              //fullscreen was enabled
              setIsFullscreen(true);
              setElement(currentFullscreenElement);
          }
          else {
              //fullscreen was disabled
              setIsFullscreen(false);
              setElement(null);
          }
          onChangeArg === null || onChangeArg === void 0 ? void 0 : onChangeArg.call(document, event, isOpen);
          (_a = onChangeDeprecatedHandlerRef.current) === null || _a === void 0 ? void 0 : _a.call(document, event, isOpen);
      });
      useDocumentEventListener(fullscreenControls.fullscreenerror, function (event) {
          var _a;
          onErrorArg === null || onErrorArg === void 0 ? void 0 : onErrorArg.call(document, event);
          (_a = onErrorDeprecatedHandlerRef.current) === null || _a === void 0 ? void 0 : _a.call(document, event);
      });
      return {
          isEnabled: Boolean(document[fullscreenControls.fullscreenEnabled]),
          toggle,
          onChange: onChangeDeprecated,
          onError: onErrorDeprecated,
          request,
          exit,
          isFullscreen,
          element,
      };
  }

  function getGeoLocation(options) {
      return new Promise((resolve, reject) => {
          if (navigator.geolocation) {
              navigator.geolocation.getCurrentPosition(res => {
                  const { coords } = res;
                  const { latitude, longitude } = coords;
                  resolve({
                      lat: latitude,
                      lng: longitude,
                      isError: false,
                      message: ""
                  });
              }, err => {
                  reject({ message: err.message, isError: true });
              }, options);
          }
          else {
              reject({
                  isError: true,
                  message: "Geolocation is not supported for this Browser/OS."
              });
          }
      });
  }
  // interface IUseGeoLocationHook {
  //   when?: boolean;
  // }
  // const defaultHookOptions = {
  //   when: true
  // };
  const defaultGeoLocationOptions = {
      enableHighAccuracy: false,
      timeout: Infinity,
      maximumAge: 0,
      when: true
  };
  /**
   * useGeolocation
   * Gets the geolocation data as a hook
   * @param geoLocationOptions Geolocation options
   */
  function useGeolocation(
  // hooksOptions: IUseGeoLocationHook = defaultHookOptions,
  geoLocationOptions = defaultGeoLocationOptions) {
      const [geoObj, setGeoObj] = react.useState(null);
      const { when, enableHighAccuracy, timeout, maximumAge } = geoLocationOptions;
      react.useEffect(() => {
          function getGeoCode() {
              return __awaiter(this, void 0, void 0, function* () {
                  try {
                      const value = yield getGeoLocation({
                          when,
                          enableHighAccuracy,
                          timeout,
                          maximumAge
                      });
                      setGeoObj(value);
                  }
                  catch (e) {
                      setGeoObj(e);
                  }
              });
          }
          if (when) {
              getGeoCode();
          }
      }, [when, enableHighAccuracy, timeout, maximumAge]);
      return geoObj;
  }

  const defaultOptions = {};
  /**
   *
   * useInput Hook
   *
   * Handles an input's value and onChange props internally to
   * make text input creation process easier
   *
   * @param {any} [initialValue=""] Initial value of the input
   * @param {Options} [opts={}] Options object
   * @returns {InputHandler} Input handler with value and onChange
   */
  function useInput(initialValue = "", opts = defaultOptions) {
      const [value, setValue] = react.useState(initialValue);
      function onChange(e) {
          const newValue = e.target.value;
          let shouldUpdate = true;
          if (typeof opts.validate === "function") {
              shouldUpdate = opts.validate(newValue, value);
          }
          if (shouldUpdate) {
              setValue(newValue);
          }
      }
      //sync with default value
      react.useEffect(() => {
          setValue(initialValue);
      }, [initialValue]);
      const handler = {
          value,
          onChange
      };
      return handler;
  }

  /**
   * A setInterval hook that calls a callback after a interval duration
   * when a condition is true
   * @param cb The callback to be invoked after interval
   * @param intervalDurationMs Amount of time in ms after which to invoke
   * @param when The condition which when true, sets the interval
   */
  function useIntervalWhen(cb, intervalDurationMs = 0, when = true) {
      const savedRefCallback = react.useRef();
      react.useEffect(() => {
          savedRefCallback.current = cb;
      });
      function callback() {
          savedRefCallback.current && savedRefCallback.current();
      }
      react.useEffect(() => {
          if (when) {
              const interval = window.setInterval(callback, intervalDurationMs);
              return () => {
                  window.clearInterval(interval);
              };
          }
      }, [when, intervalDurationMs]);
  }

  const config$2 = {
      root: null,
      rootMargin: "0px 0px 0px 0px",
      threshold: [0, 1]
  };
  /**
   *
   * useIntersectionObserverRef hook
   *
   * Returns a mutation observer for a React Ref and fires a callback
   *
   * @param {IntersectionObserverCallback} callback Function that needs to be fired on mutation
   * @param {IntersectionObserverInit} options
   */
  function useIntersectionObserverRef(callback, options = config$2) {
      const { root = null, rootMargin, threshold } = options;
      const [node, setNode] = react.useState(null);
      react.useEffect(() => {
          // Create an observer instance linked to the callback function
          if (node) {
              const observer = new IntersectionObserver(callback, options);
              // Start observing the target node for configured mutations
              observer.observe(node);
              return () => {
                  observer.disconnect();
              };
          }
      }, [node, callback, root, rootMargin, threshold]);
      const ref = react.useCallback((node) => {
          setNode(node);
      }, []);
      return [ref];
  }

  const config$3 = {
      root: null,
      rootMargin: '0px 0px 0px 0px',
      threshold: [0, 1],
  };
  /**
   *
   * useInViewRef hook
   *
   * Returns a mutation observer for a React Ref and true/false when element enters/leaves the viewport. Also fires a callback.
   *
   * @param {IntersectionObserverCallback} callback Function that needs to be fired on mutation
   * @param {IntersectionObserverInit} options
   */
  function useInViewRef(callback = () => { }, options = config$3) {
      const { root = null, rootMargin, threshold } = options;
      const [node, setNode] = react.useState(null);
      const [inView, setInView] = react.useState(false);
      react.useEffect(() => {
          // Create an observer instance linked to the callback function
          if (node) {
              const observer = new IntersectionObserver((entries, observerRef) => {
                  entries.forEach(({ isIntersecting }) => setInView(isIntersecting));
                  callback(entries, observerRef);
              }, options);
              // Start observing the target node for configured mutations
              observer.observe(node);
              return () => {
                  observer.disconnect();
              };
          }
      }, [node, callback, root, rootMargin, threshold]);
      const ref = react.useCallback((node) => {
          setNode(node);
      }, []);
      return [ref, inView];
  }

  function doesIdentifierMatchKeyboardEvent(e, identifier) {
      if (e.key === identifier ||
          e.code === identifier ||
          e.keyCode === identifier ||
          e.which === identifier ||
          e.charCode === identifier) {
          return true;
      }
      return false;
  }

  const defaultOptions$1 = {
      when: true,
      eventTypes: ["keydown"]
  };
  /**
   * useKeyRef hook
   *
   * Fires a callback on keyboard events like keyDown, keyPress and keyUp
   *
   * @param {[string|number]} keyList
   * @param {function} callback
   * @param {Options} options
   * @return callbackRef
   */
  function useKeyRef(input, callback, opts) {
      const [targetNode, setTargetNode] = react.useState(null);
      const ref = react.useCallback((targetNode) => {
          setTargetNode(targetNode);
      }, []);
      const keyList = react.useMemo(() => {
          if (Array.isArray(input)) {
              return input;
          }
          else {
              return [input];
          }
      }, [input]);
      const options = Object.assign({}, defaultOptions$1, opts);
      const { when, eventTypes } = options;
      const callbackRef = react.useRef(callback);
      react.useEffect(() => {
          callbackRef.current = callback;
      });
      const handle = react.useCallback((e) => {
          if (keyList.some(identifier => doesIdentifierMatchKeyboardEvent(e, identifier))) {
              callbackRef.current(e);
          }
      }, [keyList]);
      react.useEffect(() => {
          if (when && targetNode) {
              eventTypes.forEach(eventType => {
                  targetNode && targetNode.addEventListener(eventType, handle);
              });
              return () => {
                  eventTypes.forEach(eventType => {
                      targetNode && targetNode.removeEventListener(eventType, handle);
                  });
              };
          }
      }, [targetNode, when, eventTypes, keyList, handle]);
      return ref;
  }

  const defaultOptions$2 = {
      when: true,
      eventTypes: ["keydown"]
  };
  /**
   * useKey hook
   *
   * Fires a callback on keyboard events like keyDown, keyPress and keyUp
   *
   * @param {[string|number]} keyList
   * @param {function} callback
   * @param {Options} options
   */
  function useKey(input, callback, opts) {
      const keyList = react.useMemo(() => {
          if (Array.isArray(input)) {
              return input;
          }
          else {
              return [input];
          }
      }, [input]);
      const options = Object.assign({}, defaultOptions$2, opts);
      const { when, eventTypes } = options;
      const callbackRef = react.useRef(callback);
      let { target } = options;
      react.useEffect(() => {
          callbackRef.current = callback;
      });
      const handle = react.useCallback((e) => {
          if (keyList.some(identifier => doesIdentifierMatchKeyboardEvent(e, identifier))) {
              callbackRef.current(e);
          }
      }, [keyList]);
      react.useEffect(() => {
          if (when && typeof window !== "undefined") {
              const targetNode = target ? target.current : window;
              eventTypes.forEach(eventType => {
                  targetNode && targetNode.addEventListener(eventType, handle);
              });
              return () => {
                  eventTypes.forEach(eventType => {
                      targetNode && targetNode.removeEventListener(eventType, handle);
                  });
              };
          }
      }, [when, eventTypes, keyList, target, callback]);
  }

  /**
   * defaultOptions which will be merged with passed in options
   */
  const defaultOptions$3 = {
      when: true,
      continuous: false
  };
  /**
   * useKeys hook
   * @param keysList
   * @param callback
   * @param opts
   */
  function useKeys(keysList, callback, opts) {
      const options = Object.assign({}, defaultOptions$3, opts);
      const { target, when, continuous } = options;
      const savedCallback = react.useRef(callback);
      /**
       * PressedKeyMapping will do the bookkeeping the pressed keys
       */
      const pressedKeyMappingRef = react.useRef({});
      const PressedKeyMapping = pressedKeyMappingRef.current;
      /**
       *  First useEffect is to remember the latest callback
       */
      react.useEffect(() => {
          savedCallback.current = callback;
      });
      /**
       * handleKeyDown
       *
       * @param   {KeyboardEvent}  event
       * KeyDown event handler which will wrap the passed in callback
       */
      const handleKeyDown = react.useCallback(function handleKeyDown(event) {
          let pressedKeyIdentifier = null;
          let areAllKeysFromListPressed = false;
          // First detect the key that was pressed;
          keysList.forEach(identifier => {
              if (doesIdentifierMatchKeyboardEvent(event, identifier)) {
                  PressedKeyMapping[identifier] = true;
                  pressedKeyIdentifier = identifier;
                  return;
              }
          });
          if (keysList.every(identifier => Boolean(PressedKeyMapping[identifier]))) {
              areAllKeysFromListPressed = true;
          }
          if (areAllKeysFromListPressed) {
              if (savedCallback.current) {
                  savedCallback.current(event);
              }
              /**
               * If not continuous
               * disable identifier immediately
               */
              if (!continuous) {
                  if (pressedKeyIdentifier !== null) {
                      PressedKeyMapping[pressedKeyIdentifier] = false;
                  }
              }
          }
      }, [keysList, continuous]);
      /**
       * [handleKeyUp]
       *
       * @param   {KeyboardEvent}  event
       *
       * KeyUp event handler which will update the keys pressed state in PressedKeyMapping
       */
      const handleKeyUp = react.useCallback(function handleKeyUp(event) {
          keysList.forEach(identifier => {
              if (doesIdentifierMatchKeyboardEvent(event, identifier)) {
                  PressedKeyMapping[identifier] = undefined;
              }
          });
      }, []);
      /**
       * Responsible for setting up the event listener and removing event listeners
       */
      react.useEffect(() => {
          if (when && typeof window !== "undefined") {
              let targetNode = target && target.current ? target.current : document;
              if (targetNode) {
                  targetNode.addEventListener("keydown", handleKeyDown);
                  targetNode.addEventListener("keyup", handleKeyUp);
              }
              return () => {
                  if (targetNode)
                      targetNode.removeEventListener("keydown", handleKeyDown);
                  if (targetNode)
                      targetNode.removeEventListener("keyup", handleKeyUp);
              };
          }
      }, [when, target, keysList, handleKeyDown, handleKeyUp]);
  }

  /**
   * useLocalstorage hook
   * Tracks a value within localStorage and updates it
   * @param {string} key - Key of the localStorage object
   * @param {any} defaultValue - Default initial value
   */
  function useLocalstorage(key, defaultValue = null) {
      const [value, setValue] = react.useState(getValueFromLocalStorage());
      function init() {
          const valueLoadedFromLocalStorage = getValueFromLocalStorage();
          if (valueLoadedFromLocalStorage === null ||
              valueLoadedFromLocalStorage === "null") {
              set(defaultValue);
          }
      }
      function getValueFromLocalStorage() {
          if (typeof localStorage === "undefined") {
              return null;
          }
          const storedValue = localStorage.getItem(key) || "null";
          try {
              return JSON.parse(storedValue);
          }
          catch (err) {
              console.error(err);
          }
          return storedValue;
      }
      function saveValueToLocalStorage(key, value) {
          if (typeof localStorage === "undefined") {
              return null;
          }
          return localStorage.setItem(key, JSON.stringify(value));
      }
      function set(newValue) {
          setValue(newValue);
          saveValueToLocalStorage(key, newValue);
      }
      const listen = react.useCallback((e) => {
          if (e.storageArea === localStorage && e.key === key) {
              setValue(e.newValue);
          }
      }, []);
      function remove() {
          set(null);
          if (typeof localStorage === "undefined") {
              return false;
          }
          localStorage.removeItem(key);
      }
      //initialize
      react.useEffect(() => {
          init();
      }, []);
      // check for changes across windows
      react.useEffect(() => {
          window.addEventListener("storage", listen);
          return () => {
              window.removeEventListener("storage", listen);
          };
      }, []);
      let handler;
      handler = [value, set, remove];
      handler.value = value;
      handler.set = set;
      handler.remove = remove;
      return handler;
  }

  function getValueFromLocalStorage(key) {
      if (typeof localStorage === "undefined") {
          return null;
      }
      const storedValue = localStorage.getItem(key) || "null";
      try {
          return JSON.parse(storedValue);
      }
      catch (err) {
          console.error(err);
      }
      return storedValue;
  }
  function saveValueToLocalStorage(key, value) {
      if (typeof localStorage === "undefined") {
          return null;
      }
      return localStorage.setItem(key, JSON.stringify(value));
  }
  /**
   * @param key Key of the localStorage object
   * @param initialState Default initial value
   */
  function initialize(key, initialState) {
      const valueLoadedFromLocalStorage = getValueFromLocalStorage(key);
      if (valueLoadedFromLocalStorage === null) {
          return initialState;
      }
      else {
          return valueLoadedFromLocalStorage;
      }
  }
  /**
   * useLocalstorageState hook
   * Tracks a value within localStorage and updates it
   * @param {string} key - Key of the localStorage object
   * @param {any} initialState - Default initial value
   */
  function useLocalstorageState(key, initialState) {
      const [value, __setValue] = react.useState(() => initialize(key, initialState));
      const isUpdateFromListener = react.useRef(false);
      react.useEffect(() => {
          /**
           * We need to ensure there is no loop of
           * storage events fired. Hence we are using a ref
           * to keep track of whether setValue is from another
           * storage event
          */
          if (!isUpdateFromListener.current) {
              saveValueToLocalStorage(key, value);
          }
      }, [value]);
      const listen = react.useCallback((e) => {
          if (e.storageArea === localStorage && e.key === key) {
              try {
                  isUpdateFromListener.current = true;
                  const newValue = JSON.parse(e.newValue || "null");
                  if (value !== newValue) {
                      __setValue(newValue);
                  }
              }
              catch (err) {
                  console.log(err);
              }
          }
      }, []);
      // check for changes across windows
      react.useEffect(() => {
          window.addEventListener("storage", listen);
          return () => {
              window.removeEventListener("storage", listen);
          };
      }, []);
      function setValue(newValue) {
          isUpdateFromListener.current = false;
          __setValue(newValue);
      }
      function remove() {
          localStorage.removeItem(key);
      }
      return [value, setValue, remove];
  }

  /**
   * useMapState hook
   * A hook to manage state in the form of a map or object.
   * @param initialValue Initial value of the map
   */
  function useMapState(initialValue) {
      const [map, setMap] = react.useState(initialValue);
      function set(key, value) {
          setMap(Object.assign(Object.assign({}, map), { [key]: value }));
      }
      function has(key) {
          return typeof map[key] !== "undefined";
      }
      function setMultiple(obj) {
          setMap(Object.assign(Object.assign({}, map), obj));
      }
      function removeMultiple(...keys) {
          const newMap = {};
          Object.keys(map).forEach((key) => {
              if (!keys.includes(key)) {
                  newMap[key] = map[key];
              }
          });
          setMap(newMap);
      }
      function remove(key) {
          const newMap = {};
          Object.keys(map).forEach((mapKey) => {
              if (mapKey !== key) {
                  newMap[mapKey] = map[mapKey];
              }
          });
          setMap(newMap);
      }
      function removeAll() {
          setMap({});
      }
      const controls = {
          set,
          has,
          setMultiple,
          remove,
          removeMultiple,
          removeAll
      };
      return [map, controls];
  }

  /**
   * useMediaMatch
   *
   * A react hook that signals whether or not a media query is matched.
   *
   * @param query The media query to signal on. Example, `"print"` will signal
   * `true` when previewing in print mode, and `false` otherwise.
   * @returns Whether or not the media query is currently matched.
   */
  function useMediaMatch(query) {
      if (typeof window === 'undefined') {
          console.warn('useMediaMatch cannot function as window is undefined.');
          return false;
      }
      const matchMedia = react.useMemo(() => window.matchMedia(query), [
          query,
      ]);
      const [matches, setMatches] = react.useState(() => matchMedia.matches);
      react.useEffect(() => {
          setMatches(matchMedia.matches);
          const listener = (ev) => setMatches(ev.matches);
          matchMedia.addEventListener('change', listener);
          return () => matchMedia.removeEventListener('change', listener);
      }, [matchMedia]);
      return matches;
  }

  function setRef$1(ref, value) {
      if (typeof ref === "function") {
          ref(value);
      }
      else if (ref) {
          ref.current = value;
      }
  }
  /**
   * useMergeRefs
   * Merges multiple refs into a single function ref.
   * Takes any number of refs.
   * Refs can be mutable refs or function refs.
   * @param refs
   */
  function useMergeRefs(...refs) {
      return react.useMemo(() => {
          if (refs.every((ref) => ref === null)) {
              return null;
          }
          return (refValue) => {
              refs.forEach((ref) => {
                  setRef$1(ref, refValue);
              });
          };
      }, [...refs]);
  }

  const initialMouseState = {
      x: null,
      y: null,
      screenX: null,
      screenY: null,
      pageX: null,
      pageY: null,
      clientX: null,
      clientY: null,
      movementX: null,
      movementY: null,
      offsetX: null,
      offsetY: null
  };
  function getMousePositionFromEvent(e) {
      const { screenX, screenY, movementX, movementY, pageX, pageY, clientX, clientY, offsetX, offsetY } = e;
      return {
          screenX,
          screenY,
          movementX,
          movementY,
          pageX,
          pageY,
          clientX,
          clientY,
          offsetX,
          offsetY,
          x: screenX,
          y: screenY
      };
  }
  /**
   * useMouse hook
   *
   * Retrieves current mouse position and information about the position like
   * screenX, pageX, clientX, movementX, offsetX
   */
  function useMouse() {
      const [mousePosition, setMousePostition] = react.useState(initialMouseState);
      function updateMousePosition(e) {
          setMousePostition(getMousePositionFromEvent(e));
      }
      react.useEffect(() => {
          document.addEventListener("mousemove", updateMousePosition);
          return () => {
              document.removeEventListener("mousemove", updateMousePosition);
          };
      }, []);
      return mousePosition;
  }

  function warnIfBothValueAndIndexAreProvided(functionName, obj) {
      if (Object.values(obj).every((v) => typeof v !== "undefined")) {
          console.warn(`${functionName} .Expected either ${Object.keys(obj).join(" or ")} to be provided. However all were provided`);
      }
      else if (Object.values(obj).every((v) => typeof v === "undefined")) {
          console.warn(`${functionName} . ${Object.keys(obj).join(" , ")} are all undefined.`);
      }
  }
  /**
   * useMultiSelectableList
   * A custom hook to easily select multiple values from a list
   * @param list
   * @param initialSelectIndices
   * @param allowUnselected
   */
  function useMultiSelectableList(list = [], initialSelectIndices = [0], allowUnselected = false) {
      const [currentIndices, setCurrentIndices] = react.useState(initialSelectIndices);
      const currentValues = currentIndices.map((index) => list[index]);
      const selection = [currentIndices, currentValues];
      function updateSelections({ indices, values }) {
          return () => {
              warnIfBothValueAndIndexAreProvided("updateSelection", {
                  indices,
                  values
              });
              if (typeof indices !== "undefined") {
                  if (!allowUnselected && indices.length === 0) {
                      console.warn(`updateSelection failed. indices is an empty list.`);
                      return;
                  }
                  setCurrentIndices(indices);
              }
              else {
                  const valueIndices = list.reduce((acc, curr, index) => {
                      if (values.includes(curr)) {
                          const arr = [...acc, index];
                          return arr;
                      }
                      return acc;
                  }, []);
                  if (valueIndices.length > 0) {
                      setCurrentIndices(valueIndices);
                  }
                  else if (allowUnselected) {
                      setCurrentIndices(valueIndices);
                  }
                  else {
                      console.warn(`updateSelection failed. Do the values exist in the list?`);
                  }
              }
          };
      }
      function toggleSelectionByIndex(index) {
          let newIndices;
          if (!currentIndices.includes(index)) {
              newIndices = [...currentIndices, index];
          }
          else {
              newIndices = [...currentIndices];
              var indexOfIndex = currentIndices.indexOf(index);
              if (indexOfIndex !== -1) {
                  newIndices.splice(indexOfIndex, 1);
              }
          }
          if (newIndices.length > 0) {
              setCurrentIndices(newIndices);
          }
          else if (allowUnselected) {
              setCurrentIndices(newIndices);
          }
          else {
              console.warn(`toggleSelection failed. Do the values exist in the list?`);
          }
      }
      function toggleSelection({ index, value }) {
          return () => {
              warnIfBothValueAndIndexAreProvided("toggleSelection", {
                  index,
                  value
              });
              if (typeof index !== "undefined") {
                  toggleSelectionByIndex(index);
              }
              else {
                  const valueIndex = list.indexOf(value);
                  if (valueIndex > -1) {
                      toggleSelectionByIndex(valueIndex);
                  }
              }
          };
      }
      function matchSelection({ index, value }) {
          warnIfBothValueAndIndexAreProvided("matchSelection", { index, value });
          if (typeof index !== "undefined") {
              return currentIndices.includes(index);
          }
          else {
              return currentValues.includes(value);
          }
      }
      const controls = {
          updateSelections,
          matchSelection,
          toggleSelection
      };
      return [selection, controls];
  }

  /**
   *  useWindowEventListener hook
   *
   *  A react hook to an event listener to the window
   *
   * @param {string} eventName The event to track
   * @param {function} callback The callback to be called on event
   * @param {object} conditions The options to be passed to the event listener
   * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
   * @return {undefined}
   */
  function useWindowEventListener(eventName, callback, listenerOptions = {}, isLayoutEffect = false) {
      if (typeof window !== "undefined") {
          useGlobalObjectEventListener(window, eventName, callback, listenerOptions, true, isLayoutEffect);
      }
      else {
          console.warn("useWindowEventListener can't attach an event listener as window is undefined.");
      }
  }

  function getLanguage() {
      if (typeof navigator !== "undefined") {
          return navigator.language || navigator["userLanguage"];
      }
      else {
          return null;
      }
  }
  /**
   * useNavigatorLanguage hook
   * Returns the language of the navigator
   * @return {Language}
   */
  function useNavigatorLanguage() {
      const [language, setLanguage] = react.useState(getLanguage);
      useWindowEventListener("languagechange", () => {
          setLanguage(getLanguage);
      });
      return language;
  }

  /**
   *
   * useOnWindowResize hook
   *
   * Fires a callback when window resizes
   *
   * @param {function} callback Callback to be called before unmount
   * @param {boolean} when When the handler should be applied
   * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
   */
  function useOnWindowResize(callback, when = true, isLayoutEffect = false) {
      useGlobalObjectEventListener(window, "resize", callback, { passive: true }, when, isLayoutEffect);
  }

  /**
   *
   * useOnWindowScroll hook
   * Fires a callback when window scroll
   * @param {function} callback Callback to be called before unmount
   * @param {boolean} when When the handler should be applied
   * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
   */
  function useOnWindowScroll(callback, when = true, isLayoutEffect = false) {
      useGlobalObjectEventListener(window, "scroll", callback, { passive: true }, when, isLayoutEffect);
  }

  /**
   *
   * @returns {boolean} Is navigator online
   */
  function getIsOnline() {
      if (typeof window === 'undefined') {
          return null;
      }
      return navigator.onLine;
  }
  /**
   * useOnline hook
   *
   * Returns true if navigator is online, false if not.
   *
   * @returns {boolean} The value of navigator.onLine
   */
  function useOnline() {
      const [online, changeOnline] = react.useState(() => getIsOnline());
      function setOffline() {
          changeOnline(false);
      }
      function setOnline() {
          changeOnline(true);
      }
      // we only needs this to be set on mount
      // hence []
      react.useEffect(() => {
          window.addEventListener("online", setOnline);
          window.addEventListener("offline", setOffline);
          return () => {
              window.removeEventListener("online", setOnline);
              window.removeEventListener("offline", setOffline);
          };
      }, []);
      return online;
  }

  /**
   *  useOutsideClick hook
   * Checks if a click happened outside a Ref. Handy for dropdowns, modals and popups etc.
   * @param ref Ref whose outside click needs to be listened to
   * @param handler Callback to fire on outside click
   * @param when A boolean which which activates the hook only when it is true. Useful for conditionally enable the outside click
   */
  function useOutsideClick(ref, handler, when = true) {
      const savedHandler = react.useRef(handler);
      const memoizedCallback = react.useCallback((e) => {
          if (ref && ref.current && !ref.current.contains(e.target)) {
              savedHandler.current(e);
          }
      }, []);
      react.useEffect(() => {
          savedHandler.current = handler;
      });
      react.useEffect(() => {
          if (when) {
              document.addEventListener("click", memoizedCallback);
              document.addEventListener("ontouchstart", memoizedCallback);
              return () => {
                  document.removeEventListener("click", memoizedCallback);
                  document.removeEventListener("ontouchstart", memoizedCallback);
              };
          }
      }, [ref, handler, when]);
  }

  /**
   * useOutsideClickRef hook
   * Checks if a click happened outside a Ref. Handy for dropdowns, modals and popups etc.
   * @param handler Callback to fire on outside click
   * @param when A boolean which which activates the hook only when it is true. Useful for conditionally enable the outside click
   * @returns An array with first item being ref
   */
  function useOutsideClickRef(handler, when = true) {
      const savedHandler = react.useRef(handler);
      const [node, setNode] = react.useState(null);
      const memoizedCallback = react.useCallback((e) => {
          if (node && !node.contains(e.target)) {
              savedHandler.current(e);
          }
      }, [node]);
      react.useEffect(() => {
          savedHandler.current = handler;
      });
      const ref = react.useCallback((node) => {
          setNode(node);
      }, []);
      react.useEffect(() => {
          if (when) {
              document.addEventListener("click", memoizedCallback);
              document.addEventListener("ontouchstart", memoizedCallback);
              return () => {
                  document.removeEventListener("click", memoizedCallback);
                  document.removeEventListener("ontouchstart", memoizedCallback);
              };
          }
      }, [when, memoizedCallback]);
      return [ref];
  }

  /**
   * usePrevious hook for React
   * @param currentValue The value whose previous value is to be tracked
   * @returns The previous value
   */
  function usePrevious(currentValue) {
      const prevRef = react.useRef(null);
      react.useEffect(() => {
          prevRef.current = currentValue;
      }, [currentValue]);
      return prevRef.current;
  }

  /**
   * usePreviousDifferent hook for React
   * It returns the past value which was different from the current one.
   * @param currentValue The value whose previously different value is to be tracked
   * @returns The previous value
   */
  function usePreviousDifferent(currentValue) {
      const prevRef = react.useRef(null);
      const prevRef2 = react.useRef(null);
      react.useEffect(() => {
          prevRef2.current = prevRef.current;
          prevRef.current = currentValue;
      }, [currentValue]);
      return currentValue === prevRef.current ? prevRef2.current : prevRef.current;
  }

  /**
   * usePreviousImmediate hook for React
   * @param currentValue The value whose previous value is to be tracked
   * @returns The previous value
   */
  function usePreviousImmediate(currentValue) {
      const prevRef = react.useRef(null);
      react.useEffect(() => {
          prevRef.current = currentValue;
      });
      return prevRef.current;
  }

  function useQueueState(initialList) {
      const [list, setList] = react.useState([...initialList]);
      const length = list.length;
      function enqueue(item) {
          const newList = [...list, item];
          setList(newList);
          return newList.length;
      }
      function dequeue() {
          if (list.length > 0) {
              const firstItem = list[0];
              setList([...list.slice(1)]);
              return firstItem;
          }
          return undefined;
      }
      function peek() {
          if (length > 0) {
              return list[0];
          }
          return undefined;
      }
      const controls = {
          enqueue,
          dequeue,
          length,
          peek
      };
      return [list, controls];
  }

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  		path: basedir,
  		exports: {},
  		require: function (path, base) {
  			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
  		}
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var performanceNow = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.2
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

    if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
      module.exports = function() {
        return performance.now();
      };
    } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
      module.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      module.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }

  }).call(this);


  });

  var root$1 = typeof window === 'undefined' ? global : window
    , vendors = ['moz', 'webkit']
    , suffix = 'AnimationFrame'
    , raf = root$1['request' + suffix]
    , caf = root$1['cancel' + suffix] || root$1['cancelRequest' + suffix];

  for(var i = 0; !raf && i < vendors.length; i++) {
    raf = root$1[vendors[i] + 'Request' + suffix];
    caf = root$1[vendors[i] + 'Cancel' + suffix]
        || root$1[vendors[i] + 'CancelRequest' + suffix];
  }

  // Some versions of FF have rAF but not cAF
  if(!raf || !caf) {
    var last = 0
      , id = 0
      , queue = []
      , frameDuration = 1000 / 60;

    raf = function(callback) {
      if(queue.length === 0) {
        var _now = performanceNow()
          , next = Math.max(0, frameDuration - (_now - last));
        last = next + _now;
        setTimeout(function() {
          var cp = queue.slice(0);
          // Clear queue here to prevent
          // callbacks from appending listeners
          // to the current frame's queue
          queue.length = 0;
          for(var i = 0; i < cp.length; i++) {
            if(!cp[i].cancelled) {
              try{
                cp[i].callback(last);
              } catch(e) {
                setTimeout(function() { throw e }, 0);
              }
            }
          }
        }, Math.round(next));
      }
      queue.push({
        handle: ++id,
        callback: callback,
        cancelled: false
      });
      return id
    };

    caf = function(handle) {
      for(var i = 0; i < queue.length; i++) {
        if(queue[i].handle === handle) {
          queue[i].cancelled = true;
        }
      }
    };
  }

  var raf_1 = function(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root$1, fn)
  };
  var cancel = function() {
    caf.apply(root$1, arguments);
  };
  var polyfill = function(object) {
    if (!object) {
      object = root$1;
    }
    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
  };
  raf_1.cancel = cancel;
  raf_1.polyfill = polyfill;

  /**
   *
   * useRaf
   * Uses a polyfilled version of requestAnimationFrame
   * @param {function} callback The callback function to be executed
   * @param {boolean} [isActive=true] The value which while true, keeps the raf running infinitely
   */
  function useRaf(callback, isActive) {
      const savedCallback = react.useRef();
      // Remember the latest function.
      react.useEffect(() => {
          savedCallback.current = callback;
      }, [callback]);
      react.useEffect(() => {
          let startTime, animationFrame;
          function tick() {
              const timeElapsed = Date.now() - startTime;
              startTime = Date.now();
              loop();
              savedCallback.current && savedCallback.current(timeElapsed);
          }
          function loop() {
              animationFrame = raf_1(tick);
          }
          if (isActive) {
              startTime = Date.now();
              loop();
              return () => {
                  raf_1.cancel(animationFrame);
              };
          }
      }, [isActive]);
  }

  /**
   * useSelect hook
   * Helps easily select a value from a list of values
   * @param list List of values to select a value from
   * @param [initialIndex=0] Initial index which is selected
   * @returns handler
   */
  function useSelect(list, initialIndex = 0) {
      const [selectedIndex, setSelectedIndex] = react.useState(initialIndex);
      function setItem(item) {
          setSelectedIndex(list.indexOf(item));
      }
      return {
          index: selectedIndex,
          item: list[selectedIndex],
          setIndex: setSelectedIndex,
          setItem
      };
  }

  function warnIfBothValueAndIndexAreProvided$1(functionName, obj) {
      if (Object.values(obj).every((v) => typeof v !== "undefined")) {
          console.warn(`${functionName} .Expected either ${Object.keys(obj).join(" or ")} to be provided. However all were provided`);
      }
      else if (Object.values(obj).every((v) => typeof v === "undefined")) {
          console.warn(`${functionName} . ${Object.keys(obj).join(" , ")} are all undefined.`);
      }
  }
  /**
   * useSelectableList
   * Easily select a single value from a list of values. very useful for radio buttons, select inputs  etc.
   * @param list
   * @param initialIndex
   * @param allowUnselected
   */
  function useSelectableList(list = [], initialIndex = 0, allowUnselected = false) {
      const [currentIndex, setCurrentIndex] = react.useState(initialIndex);
      const currentValue = list[currentIndex];
      const selection = [currentIndex, currentValue];
      function updateSelection({ index, value }) {
          return () => {
              warnIfBothValueAndIndexAreProvided$1("updateSelection", { index, value });
              if (typeof index !== "undefined") {
                  setCurrentIndex(index);
              }
              else {
                  const valueIndex = list.indexOf(value);
                  if (valueIndex > -1) {
                      setCurrentIndex(valueIndex);
                  }
                  else {
                      console.warn(`updateSelection failed. Does the value ${value} exist in the list?`);
                  }
              }
          };
      }
      function toggleSelection({ index, value }) {
          return () => {
              warnIfBothValueAndIndexAreProvided$1("toggleSelection", { index, value });
              if (typeof index !== "undefined") {
                  if (currentIndex === index) {
                      if (allowUnselected) {
                          setCurrentIndex(-1);
                      }
                      else {
                          console.log("allowUnselected is false. Cannot unselect item");
                      }
                  }
                  else {
                      setCurrentIndex(index);
                  }
              }
              else {
                  const valueIndex = list.indexOf(value);
                  if (valueIndex > -1) {
                      if (currentIndex === valueIndex) {
                          if (allowUnselected) {
                              setCurrentIndex(-1);
                          }
                          else {
                              console.log("allowUnselected is false. Cannot unselect item");
                          }
                      }
                      else {
                          setCurrentIndex(valueIndex);
                      }
                  }
                  else {
                      console.warn(`toggleSelection failed. Does the value ${value} exist in the list?`);
                  }
              }
          };
      }
      function matchSelection({ index, value }) {
          warnIfBothValueAndIndexAreProvided$1("matchSelection", { index, value });
          if (typeof index !== "undefined") {
              return index === currentIndex;
          }
          else {
              return value === currentValue;
          }
      }
      const controls = {
          updateSelection, matchSelection, toggleSelection
      };
      return [selection, controls];
  }

  function reducer(state, action) {
      switch (action.type) {
          case "set":
              return (state = action.payload);
          default:
              return state;
      }
  }
  /**
   * useSessionstorage
   * Tracks a value within sessionStorage and updates it
   * @param key Key of the value to be stored
   * @param defaultValue Default value of the stored item
   */
  function useSessionstorage(key, defaultValue = null) {
      const [value, dispatch] = react.useReducer(reducer, getValueFromSessionStorage());
      function init() {
          const initialValue = getValueFromSessionStorage();
          if (initialValue === null || initialValue === "null") {
              set(defaultValue);
          }
      }
      function getValueFromSessionStorage() {
          if (typeof sessionStorage === "undefined") {
              return null;
          }
          const storedValue = sessionStorage.getItem(key) || "null";
          try {
              return JSON.parse(storedValue);
          }
          catch (err) {
              console.error(err);
          }
          return storedValue;
      }
      function saveValueToSessionStorage(key, value) {
          if (typeof sessionStorage === "undefined") {
              return null;
          }
          return sessionStorage.setItem(key, JSON.stringify(value));
      }
      function setValue(value) {
          dispatch({
              type: "set",
              payload: value
          });
      }
      function set(newValue) {
          saveValueToSessionStorage(key, newValue);
          setValue(newValue);
      }
      function remove() {
          if (typeof sessionStorage === "undefined") {
              return null;
          }
          sessionStorage.removeItem(key);
          setValue(null);
      }
      react.useEffect(() => {
          init();
      }, []);
      const listen = react.useCallback((e) => {
          if (e.storageArea === sessionStorage && e.key === key) {
              set(e.newValue);
          }
      }, []);
      react.useEffect(() => {
          window.addEventListener("storage", listen);
          return () => {
              window.removeEventListener("storage", listen);
          };
      }, []);
      let handler;
      handler = [value, set, remove];
      handler.value = value;
      handler.set = set;
      handler.remove = remove;
      return handler;
  }

  function getValueFromSessionStorage(key) {
      if (typeof sessionStorage === "undefined") {
          return null;
      }
      const storedValue = sessionStorage.getItem(key) || "null";
      try {
          return JSON.parse(storedValue);
      }
      catch (err) {
          console.error(err);
      }
      return storedValue;
  }
  function saveValueToSessionStorage(key, value) {
      if (typeof sessionStorage === "undefined") {
          return null;
      }
      return sessionStorage.setItem(key, JSON.stringify(value));
  }
  /**
   * @param key Key of the sessionStorage object
   * @param initialState Default initial value
   */
  function initialize$1(key, initialState) {
      const valueLoadedFromSessionStorage = getValueFromSessionStorage(key);
      if (valueLoadedFromSessionStorage === null) {
          return initialState;
      }
      else {
          return valueLoadedFromSessionStorage;
      }
  }
  /**
   * useSessionstorageState hook
   * Tracks a value within sessionStorage and updates it
   * @param {string} key - Key of the sessionStorage object
   * @param {any} initialState - Default initial value
   */
  function useSessionstorageState(key, initialState) {
      const [value, __setValue] = react.useState(() => initialize$1(key, initialState));
      const isUpdateFromListener = react.useRef(false);
      react.useEffect(() => {
          /**
           * We need to ensure there is no loop of
           * storage events fired. Hence we are using a ref
           * to keep track of whether setValue is from another
           * storage event
          */
          if (!isUpdateFromListener.current) {
              saveValueToSessionStorage(key, value);
          }
      }, [value]);
      const listen = react.useCallback((e) => {
          if (e.storageArea === sessionStorage && e.key === key) {
              try {
                  isUpdateFromListener.current = true;
                  const newValue = JSON.parse(e.newValue || "null");
                  if (value !== newValue) {
                      __setValue(newValue);
                  }
              }
              catch (err) {
                  console.log(err);
              }
          }
      }, []);
      // check for changes across windows
      react.useEffect(() => {
          window.addEventListener("storage", listen);
          return () => {
              window.removeEventListener("storage", listen);
          };
      }, []);
      function setValue(newValue) {
          isUpdateFromListener.current = false;
          __setValue(newValue);
      }
      function remove() {
          sessionStorage.removeItem(key);
      }
      return [value, setValue, remove];
  }

  function useStackState(initialList) {
      const [list, setList] = react.useState([...initialList]);
      const length = list.length;
      const listInReverse = react.useMemo(() => {
          const reverseList = [...list];
          reverseList.reverse();
          return reverseList;
      }, [list]);
      function push(item) {
          const newList = [...list, item];
          setList(newList);
          return newList.length;
      }
      function pop() {
          if (list.length > 0) {
              const lastItem = list[list.length - 1];
              setList([...list.slice(0, list.length - 1)]);
              return lastItem;
          }
          return undefined;
      }
      function peek() {
          if (length > 0) {
              return list[length - 1];
          }
          return undefined;
      }
      const controls = {
          push,
          pop,
          length,
          peek
      };
      return [list, controls, listInReverse];
  }

  /**
   * useThrottle
   * Throttles a function with a timeout and ensures
   * that the callback function runs at most once in that duration
   * @param fn The callback to throttle
   * @param timeout Throttle timeout
   */
  function useThrottle(fn, timeout = 300) {
      const [ready, setReady] = react.useState(true);
      const timerRef = react.useRef(undefined);
      if (!fn || typeof fn !== "function") {
          throw new Error("As a first argument, you need to pass a function to useThrottle hook.");
      }
      const throttledFn = react.useCallback((...args) => {
          if (!ready) {
              return;
          }
          setReady(false);
          fn(...args);
      }, [ready, fn]);
      react.useEffect(() => {
          if (!ready) {
              timerRef.current = window.setTimeout(() => {
                  setReady(true);
              }, timeout);
              return () => window.clearTimeout(timerRef.current);
          }
      }, [ready, timeout]);
      return [throttledFn, ready];
  }

  var constant = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * Created by hustcc on 18/5/20.
   * Contract: i@hust.cc
   */

  var IndexMapEn = exports.IndexMapEn = 'second_minute_hour_day_week_month_year'.split('_');

  var IndexMapZH = exports.IndexMapZH = '______'.split('_');

  var ATTR_DATA_TID = exports.ATTR_DATA_TID = 'data-tid';

  var SEC_ARRAY = exports.SEC_ARRAY = [60, 60, 24, 7, 365 / 7 / 12, 12];

  var ATTR_TIMEAGO = exports.ATTR_TIMEAGO = 'data-timeago';
  var ATTR_DATETIME = exports.ATTR_DATETIME = 'datetime';
  });

  var locales = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.register = exports.Locales = undefined;



  var zh_CN = function zh_CN(number, index) {
    if (index === 0) return ['', ''];
    var unit = constant.IndexMapZH[parseInt(index / 2)];
    return [number + ' ' + unit + '\u524D', number + ' ' + unit + '\u540E'];
  }; /**
      * Created by hustcc on 18/5/20.
      * Contract: i@hust.cc
      */

  var en = function en(number, index) {
    if (index === 0) return ['just now', 'right now'];
    var unit = constant.IndexMapEn[parseInt(index / 2)];
    if (number > 1) unit += 's';
    return [number + ' ' + unit + ' ago', 'in ' + number + ' ' + unit];
  };

  /**
   * 
   * @type {{en: function(*, *), zh_CN: function(*, *)}}
   */
  var Locales = exports.Locales = {
    en: en,
    zh_CN: zh_CN
  };

  /**
   * 
   * @param locale
   * @param func
   */
  var register = exports.register = function register(locale, func) {
    Locales[locale] = func;
  };
  });

  var helper = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.setTidAttr = exports.getDateAttr = exports.getAttr = exports.nextInterval = exports.diffSec = exports.formatDiff = exports.toDate = exports.toInt = undefined;





  /**
   * change f into int, remove decimal. Just for code compression
   * @param f
   * @returns {number}
   */
  /**
   * Created by hustcc on 18/5/20.
   * Contract: i@hust.cc
   */

  var toInt = exports.toInt = function toInt(f) {
    return parseInt(f);
  };

  /**
   * format Date / string / timestamp to Date instance.
   * @param input
   * @returns {*}
   */
  var toDate = exports.toDate = function toDate(input) {
    if (input instanceof Date) return input;
    if (!isNaN(input) || /^\d+$/.test(input)) return new Date(toInt(input));
    input = (input || '').trim().replace(/\.\d+/, '') // remove milliseconds
    .replace(/-/, '/').replace(/-/, '/').replace(/(\d)T(\d)/, '$1 $2').replace(/Z/, ' UTC') // 2017-2-5T3:57:52Z -> 2017-2-5 3:57:52UTC
    .replace(/([\+\-]\d\d)\:?(\d\d)/, ' $1$2'); // -04:00 -> -0400
    return new Date(input);
  };

  /**
   * format the diff second to *** time ago, with setting locale
   * @param diff
   * @param locale
   * @param defaultLocale
   * @returns {string | void | *}
   */
  var formatDiff = exports.formatDiff = function formatDiff(diff, locale, defaultLocale) {
    // if locale is not exist, use defaultLocale.
    // if defaultLocale is not exist, use build-in `en`.
    // be sure of no error when locale is not exist.
    locale = locales.Locales[locale] ? locale : locales.Locales[defaultLocale] ? defaultLocale : 'en';
    var i = 0,
        agoin = diff < 0 ? 1 : 0,
        // timein or timeago
    total_sec = diff = Math.abs(diff);

    for (; diff >= constant.SEC_ARRAY[i] && i < constant.SEC_ARRAY.length; i++) {
      diff /= constant.SEC_ARRAY[i];
    }
    diff = toInt(diff);
    i *= 2;

    if (diff > (i === 0 ? 9 : 1)) i += 1;
    return locales.Locales[locale](diff, i, total_sec)[agoin].replace('%s', diff);
  };

  /**
   * calculate the diff second between date to be formatted an now date.
   * @param date
   * @param nowDate
   * @returns {number}
   */
  var diffSec = exports.diffSec = function diffSec(date, nowDate) {
    nowDate = nowDate ? toDate(nowDate) : new Date();
    return (nowDate - toDate(date)) / 1000;
  };

  /**
   * nextInterval: calculate the next interval time.
   * - diff: the diff sec between now and date to be formatted.
   *
   * What's the meaning?
   * diff = 61 then return 59
   * diff = 3601 (an hour + 1 second), then return 3599
   * make the interval with high performance.
   **/
  var nextInterval = exports.nextInterval = function nextInterval(diff) {
    var rst = 1,
        i = 0,
        d = Math.abs(diff);
    for (; diff >= constant.SEC_ARRAY[i] && i < constant.SEC_ARRAY.length; i++) {
      diff /= constant.SEC_ARRAY[i];
      rst *= constant.SEC_ARRAY[i];
    }
    d = d % rst;
    d = d ? rst - d : rst;
    return Math.ceil(d);
  };

  /**
   * get the node attribute, native DOM and jquery supported.
   * @param node
   * @param name
   * @returns {*}
   */
  var getAttr = exports.getAttr = function getAttr(node, name) {
    if (node.getAttribute) return node.getAttribute(name); // native dom
    if (node.attr) return node.attr(name); // jquery dom
  };

  /**
   * get the datetime attribute, `data-timeagp` / `datetime` are supported.
   * @param node
   * @returns {*}
   */
  var getDateAttr = exports.getDateAttr = function getDateAttr(node) {
    return getAttr(node, constant.ATTR_TIMEAGO) || getAttr(node, constant.ATTR_DATETIME);
  };

  /**
   * set the node attribute, native DOM and jquery supported.
   * @param node
   * @param val
   * @returns {*}
   */
  var setTidAttr = exports.setTidAttr = function setTidAttr(node, val) {
    if (node.setAttribute) return node.setAttribute(constant.ATTR_DATA_TID, val);
    if (node.attr) return node.attr(constant.ATTR_DATA_TID, val);
  };
  });

  var timer = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.run = exports.cancel = exports.Timers = undefined;





  // 
  /**
   * Created by hustcc on 18/5/20.
   * Contract: i@hust.cc
   */

  var Timers = exports.Timers = [];

  var clear = function clear(tid) {
    if (tid) {
      clearTimeout(tid);
      delete Timers[tid];
    }
  };

  /**
   * 
   * @param node
   */
  var cancel = exports.cancel = function cancel(node) {
    if (node) clear((0, helper.getAttr)(node, constant.ATTR_DATA_TID)); // get the timer of DOM node(native / jq).
    else for (var tid in Timers) {
        clear(tid);
      }
  };

  /**
   *  timer
   * @param func
   * @param delay
   */
  var run = exports.run = function run(func, delay) {
    var tid = setTimeout(function () {
      //  Timer 
      clear(tid);
      // 
      func();
    }, delay);

    // there is no need to save node in object. Just save the key
    Timers[tid] = 0;
    return tid;
  };
  });

  var TimeAgo_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TimeAgo = undefined;

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        * Created by hustcc on 18/5/20.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        * Contract: i@hust.cc
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        */





  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var TimeAgo = exports.TimeAgo = function () {
    function TimeAgo(nowDate, defaultLocale) {
      _classCallCheck(this, TimeAgo);

      this.nowDate = nowDate;
      this.defaultLocale = defaultLocale || 'en';
    }

    _createClass(TimeAgo, [{
      key: 'setLocale',
      value: function setLocale(locale) {
        this.defaultLocale = locale;
      }

      /**
       * render 
       * @param node
       * @param date
       * @param locale
       */

    }, {
      key: 'doRender',
      value: function doRender(node, date, locale) {
        var _this = this;

        var diff = (0, helper.diffSec)(date, this.nowDate);
        // render
        node.innerHTML = (0, helper.formatDiff)(diff, locale, this.defaultLocale);

        // waiting %s seconds, do the next render
        var tid = (0, timer.run)(function () {
          _this.doRender(node, date, locale);
        }, Math.min((0, helper.nextInterval)(diff) * 1000, 0x7FFFFFFF));

        // set attribute date-tid
        (0, helper.setTidAttr)(node, tid);
      }

      /**
       * render: render the DOM real-time.
       * - nodes: which nodes will be rendered.
       * - locale: the locale name used to format date.
       *
       * How to use it?
       * var timeago = require('timeago.js')();
       * // 1. javascript selector
       * timeago.render(document.querySelectorAll('.need_to_be_rendered'));
       * // 2. use jQuery selector
       * timeago.render($('.need_to_be_rendered'), 'pl');
       *
       * Notice: please be sure the dom has attribute `datetime`.
       */

    }, {
      key: 'render',
      value: function render(nodes, locale) {
        // by .length
        if (nodes.length === undefined) nodes = [nodes];

        var node = void 0;
        for (var i = 0, len = nodes.length; i < len; i++) {
          node = nodes[i];
          // clear node's timer
          (0, timer.cancel)(node);
          this.doRender(node, (0, helper.getDateAttr)(node), locale); // render item
        }
      }

      /**
       * format: format the date to *** time ago, with setting or default locale
       * - date: the date / string / timestamp to be formatted
       * - locale: the formatted string's locale name, e.g. en / zh_CN
       *
       * How to use it?
       * var timeago = require('timeago.js')();
       * timeago.format(new Date(), 'pl'); // Date instance
       * timeago.format('2016-09-10', 'fr'); // formated date string
       * timeago.format(1473473400269); // timestamp with ms
       */

    }, {
      key: 'format',
      value: function format(date, locale) {
        return (0, helper.formatDiff)((0, helper.diffSec)(date, this.nowDate), locale, this.defaultLocale);
      }
    }]);

    return TimeAgo;
  }();
  });

  var lib = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });







  // 
  var factory = function factory(nowDate, locale) {
    return new TimeAgo_1.TimeAgo(nowDate, locale);
  };

  /**
   * 
   */
  /**
   * Created by hustcc on 18/5/20.
   * Contract: i@hust.cc
   */

  factory.register = locales.register;

  /**
   * 
   */
  factory.cancel = timer.cancel;

  exports.default = factory;
  module.exports = exports['default'];
  });

  var timeago = /*@__PURE__*/getDefaultExportFromCjs(lib);

  const defaultOpts = {
      intervalMs: 1000
  };
  function computeTimeAgo(input, locale, relativeDate) {
      let instance;
      if (relativeDate) {
          instance = timeago(relativeDate);
      }
      else {
          instance = timeago();
      }
      return instance.format(input, locale);
  }
  function reducer$1(state, action) {
      switch (action.type) {
          case "update":
              var { input, locale, relativeDate } = action.payload;
              return computeTimeAgo(input, locale, relativeDate);
          default:
              return state;
      }
  }
  /**
   * useTimeAgo hook
   * A hook that gives a human readable format of how much time has passed since a time
   * @deprecated
   * @param input
   * @param argOpts
   */
  function useTimeAgo(input, argOpts) {
      const opts = Object.assign({}, argOpts, defaultOpts);
      const { intervalMs, locale, relativeDate } = opts;
      const [state, dispatcher] = react.useReducer(reducer$1, computeTimeAgo(input, locale, relativeDate));
      useInterval(() => {
          update();
      }, intervalMs, true);
      react.useEffect(() => {
          update();
      }, [input, argOpts]);
      return state;
      function update() {
          dispatcher({
              type: "update",
              payload: {
                  input,
                  locale,
                  relativeDate
              }
          });
      }
  }

  /**
   * A setTimeout hook that calls a callback after a timeout duration
   * @param cb The callback to be invoked after timeout
   * @param timeoutDelayMs Amount of time in ms after which to invoke
   */
  function useTimeout(cb, timeoutDelayMs = 0) {
      const [isTimeoutActive, setIsTimeoutActive] = react.useState(false);
      const savedRefCallback = react.useRef();
      react.useEffect(() => {
          savedRefCallback.current = cb;
      }, [cb]);
      function callback() {
          savedRefCallback.current && savedRefCallback.current();
          clear();
      }
      function clear() {
          setIsTimeoutActive(false);
      }
      function start() {
          setIsTimeoutActive(true);
      }
      react.useEffect(() => {
          if (isTimeoutActive) {
              const timeout = window.setTimeout(callback, timeoutDelayMs);
              return () => {
                  window.clearTimeout(timeout);
              };
          }
      }, [isTimeoutActive, timeoutDelayMs]);
      return {
          clear,
          start,
          stop: clear,
          isActive: isTimeoutActive
      };
  }

  /**
   * A setTimeout hook that calls a callback after a timeout duration
   * when a condition is true
   * @param cb The callback to be invoked after timeout
   * @param timeoutDelayMs Amount of time in ms after which to invoke
   * @param when The condition which when true, sets the timeout
   */
  function useTimeoutWhen(cb, timeoutDelayMs = 0, when = true) {
      const savedRefCallback = react.useRef();
      react.useEffect(() => {
          savedRefCallback.current = cb;
      });
      function callback() {
          savedRefCallback.current && savedRefCallback.current();
      }
      react.useEffect(() => {
          if (when) {
              const timeout = window.setTimeout(callback, timeoutDelayMs);
              return () => {
                  window.clearTimeout(timeout);
              };
          }
      }, [when]);
  }

  const defaultToggleFunction = (v) => !v;
  /**
   * Use toggle hook helps you easily toggle a value
   * @param initialValue Initial value of the toggle
   * @param toggleFunction A toggle function. This allows for non boolean toggles
   */
  function useToggle(initialValue = false, toggleFunction = defaultToggleFunction) {
      return react.useReducer(toggleFunction, initialValue);
  }

  const defaultOptions$4 = { maxSize: 100 };
  /**
   * useUndoState hook
   * Drop in replacement for useState hook but with undo functionality.
   *
   * @param {any} defaultValue
   * @param {UndoStateOptions} [{ maxSize }=defaultOptions]
   * @returns {[any, Function, Function]}
   */
  const useUndoState = (defaultValue, options) => {
      const { maxSize } = Object.assign({}, defaultOptions$4, options);
      const [value, setValue] = react.useState([defaultValue]);
      const push = react.useCallback((setterOrValue) => {
          return setValue((current) => {
              const restValues = current.length >= maxSize ? current.slice(0, maxSize) : current;
              if (typeof setterOrValue === "function") {
                  return [setterOrValue(current[0]), ...restValues];
              }
              else {
                  return [setterOrValue, ...restValues];
              }
          });
      }, [maxSize]);
      const undo = react.useCallback(() => {
          setValue((current) => {
              if (current.length === 1) {
                  return current;
              }
              const [, ...values] = current;
              return values;
          });
      }, []);
      return [value[0], push, undo];
  };

  /**
   *  useDidUpdate hook
   *
   *  Fires a callback on component update
   *  Can take in a list of conditions to fire callback when one of the
   *  conditions changes
   *  Will fire callback's cleanup function on update
   *
   * @param {function} callback The callback and its cleanup to be called on update
   * @param {Array} conditions The list of variables which trigger update when they are changed
   * @return {undefined}
   */
  function useUpdateEffect(callback, conditions) {
      const hasMountedRef = react.useRef(false);
      if (typeof conditions !== "undefined" && !Array.isArray(conditions)) {
          conditions = [conditions];
      }
      else if (Array.isArray(conditions) && conditions.length === 0) {
          console.warn("Using [] as the second argument makes useUpdateEffect a noop. The second argument should either be `undefined` or an array of length greater than 0.");
      }
      react.useEffect(() => {
          if (hasMountedRef.current) {
              return callback();
          }
          else {
              hasMountedRef.current = true;
          }
      }, conditions);
  }

  // Massive respect for Josh Johnston
  function normalizeRect(rect) {
      if (rect.width === undefined) {
          rect.width = rect.right - rect.left;
      }
      if (rect.height === undefined) {
          rect.height = rect.bottom - rect.top;
      }
      return rect;
  }
  const initialState = { isVisible: null, visibilityRect: {} };
  function reducer$2(state, action) {
      switch (action.type) {
          case "set":
              if (state.isVisible === action.payload.isVisible) {
                  return state;
              }
              return action.payload;
          default:
              return state;
      }
  }
  const DEFAULT_OPTIONS = {
      intervalCheck: false,
      partialVisibility: false,
      containment: null,
      scrollCheck: true,
      scrollDebounce: 250,
      scrollThrottle: -1,
      resizeCheck: false,
      resizeDebounce: 250,
      resizeThrottle: -1,
      shouldCheckOnMount: true,
      minTopValue: 0
  };
  /**
   * useVisibilitySensor hook
   * Tracks the visibility of a ref
   *
   * @param ref The ref to track visibility of
   * @param opts Options
   */
  function useVisibilitySensor(ref, opts) {
      /*
          Create local state
        */
      const [localState, dispatch] = react.useReducer(reducer$2, initialState);
      /*
          Get options
        */
      const { containment, intervalCheck, scrollCheck, shouldCheckOnMount, scrollDebounce, scrollThrottle, resizeCheck, resizeDebounce, resizeThrottle, partialVisibility, minTopValue } = Object.assign({}, DEFAULT_OPTIONS, opts);
      function getContainer() {
          return containment || window;
      }
      /*
          Check visibility
        */
      function checkVisibility() {
          let containmentRect;
          if (containment) {
              const containmentDOMRect = containment.getBoundingClientRect();
              containmentRect = {
                  top: containmentDOMRect.top,
                  left: containmentDOMRect.left,
                  bottom: containmentDOMRect.bottom,
                  right: containmentDOMRect.right
              };
          }
          else {
              containmentRect = {
                  top: 0,
                  left: 0,
                  bottom: window.innerHeight || document.documentElement.clientHeight,
                  right: window.innerWidth || document.documentElement.clientWidth
              };
          }
          const rect = normalizeRect(ref.current.getBoundingClientRect());
          const hasSize = rect.height > 0 && rect.width > 0;
          const visibilityRect = {
              top: rect.top >= containmentRect.top,
              left: rect.left >= containmentRect.left,
              bottom: rect.bottom <= containmentRect.bottom,
              right: rect.right <= containmentRect.right
          };
          let isVisible = hasSize &&
              visibilityRect.top &&
              visibilityRect.left &&
              visibilityRect.bottom &&
              visibilityRect.right;
          // check for partial visibility
          if (hasSize && partialVisibility) {
              let partialVisible = rect.top <= containmentRect.bottom &&
                  rect.bottom >= containmentRect.top &&
                  rect.left <= containmentRect.right &&
                  rect.right >= containmentRect.left;
              // account for partial visibility on a single edge
              if (typeof partialVisibility === "string") {
                  partialVisible = visibilityRect[partialVisibility];
              }
              // if we have minimum top visibility set by props, lets check, if it meets the passed value
              // so if for instance element is at least 200px in viewport, then show it.
              isVisible = minTopValue
                  ? partialVisible && rect.top <= containmentRect.bottom - minTopValue
                  : partialVisible;
          }
          return { isVisible, visibilityRect };
      }
      function updateIsVisible() {
          if (!ref.current) {
              return;
          }
          const { isVisible, visibilityRect } = checkVisibility();
          dispatch({
              type: "set",
              payload: { isVisible, visibilityRect }
          });
      }
      // run only once, hence empty array as second argument
      react.useEffect(() => {
          if (shouldCheckOnMount) {
              updateIsVisible();
          }
      }, []);
      react.useEffect(() => {
          updateIsVisible();
      }, [ref.current]);
      // If interval check is needed
      react.useEffect(() => {
          if (intervalCheck && intervalCheck > 0) {
              const intervalTimer = setInterval(() => {
                  updateIsVisible();
              }, intervalCheck);
              return () => {
                  clearInterval(intervalTimer);
              };
          }
      }, [intervalCheck]);
      function createListener(event, debounce, throttle) {
          const container = getContainer();
          let timeout;
          let listener;
          const later = () => {
              timeout = null;
              updateIsVisible();
          };
          if (throttle > -1) {
              listener = () => {
                  if (!timeout) {
                      timeout = setTimeout(later, throttle || 0);
                  }
              };
          }
          else {
              listener = () => {
                  clearTimeout(timeout);
                  timeout = setTimeout(later, debounce || 0);
              };
          }
          container.addEventListener(event, listener);
          return () => {
              clearTimeout(timeout);
              container.removeEventListener(event, listener);
          };
      }
      // If scroll check is needed
      useIsomorphicEffect(() => {
          if (scrollCheck) {
              return createListener("scroll", scrollDebounce, scrollThrottle);
          }
      }, []);
      // if resize check is needed
      useIsomorphicEffect(() => {
          if (resizeCheck) {
              return createListener("resize", resizeDebounce, resizeThrottle);
          }
      }, []);
      return localState;
  }

  /**
   * useWillUnmount hook
   * Fires a callback just before component unmounts
   * @param {function} callback Callback to be called before unmount
   */
  function useWillUnmount(callback) {
      // run only once
      react.useEffect(() => {
          return callback;
      }, []);
  }

  function getScrollPosition() {
      if (typeof window !== "undefined") {
          return {
              scrollX: window.pageXOffset,
              scrollY: window.pageYOffset
          };
      }
      else {
          return {
              scrollX: 0,
              scrollY: 0
          };
      }
  }
  /**
   *
   * useWindowScrollPosition hook
   * A React hook to get the scroll position of the window
   * @returns an object containing scrollX and scrollY values
   */
  function useWindowScrollPosition() {
      const [scrollPosition, setScrollPosition] = react.useState(getScrollPosition);
      /**
       * Recalculate on scroll
      */
      useOnWindowScroll(function () {
          setScrollPosition(getScrollPosition());
      }, true, true);
      /**
       * Recalculate on resize
      */
      useOnWindowResize(function () {
          setScrollPosition(getScrollPosition());
      }, true, true);
      return scrollPosition;
  }

  const nullDimensions = {
      innerWidth: null,
      innerHeight: null,
      outerWidth: null,
      outerHeight: null
  };
  function getDimensions() {
      return {
          innerWidth: window.innerWidth,
          innerHeight: window.innerHeight,
          outerWidth: window.outerWidth,
          outerHeight: window.outerHeight
      };
  }
  /**
   * useWindowSize hook
   * A hook that provides information of the dimensions of the window
   * @return Dimensions of the window
   */
  function useWindowSize() {
      const [windowSize, setWindowSize] = react.useState(() => {
          if (typeof window !== "undefined") {
              return getDimensions();
          }
          else {
              return nullDimensions;
          }
      });
      // set resize handler once on mount and clean before unmount
      useIsomorphicEffect(() => {
          function onResize() {
              setWindowSize(getDimensions());
          }
          window.addEventListener("resize", onResize);
          return () => {
              window.removeEventListener("resize", onResize);
          };
      }, []);
      return windowSize;
  }

  /**
   * useWorker hook
   * Helps you run a worker from within React
   * @param {string} scriptPath - Path of the worker
   * @param {object} workerOptions - Additional options to create the worker
   * @param {object} attributes - Event handlers to attach to the worker
   * @return {Worker}
   */
  function useWorker(scriptPath, workerOptions, attributes) {
      const [worker, setWorker] = react.useState(undefined);
      react.useEffect(() => {
          const _worker = new Worker(scriptPath, workerOptions);
          // attach attributes
          if (attributes) {
              for (const key in attributes) {
                  _worker[key] = attributes[key];
              }
          }
          setWorker(_worker);
          return () => {
              _worker.terminate();
              setWorker(undefined);
          };
      }, [scriptPath]);
      return worker;
  }

  exports.useBoundingclientrect = useBoundingclientrect;
  exports.useBoundingclientrectRef = useBoundingclientrectRef;
  exports.useCountdown = useCountdown;
  exports.useCounter = useCounter;
  exports.useDebounce = useDebounce;
  exports.useDidMount = useDidMount;
  exports.useDidUpdate = useDidUpdate;
  exports.useDocumentEventListener = useDocumentEventListener;
  exports.useEffectOnceWhen = useEffectOnceWhen;
  exports.useEventListenerRef = useEventListenerRef;
  exports.useForkRef = useForkRef;
  exports.useFreshRef = useFreshRef;
  exports.useFreshTick = useFreshTick;
  exports.useFullscreen = useFullscreen;
  exports.useGeolocation = useGeolocation;
  exports.useInViewRef = useInViewRef;
  exports.useInput = useInput;
  exports.useIntersectionObserverRef = useIntersectionObserverRef;
  exports.useInterval = useInterval;
  exports.useIntervalWhen = useIntervalWhen;
  exports.useIsomorphicEffect = useIsomorphicEffect;
  exports.useKey = useKey;
  exports.useKeyRef = useKeyRef;
  exports.useKeys = useKeys;
  exports.useLocalstorage = useLocalstorage;
  exports.useLocalstorageState = useLocalstorageState;
  exports.useMapState = useMapState;
  exports.useMediaMatch = useMediaMatch;
  exports.useMergeRefs = useMergeRefs;
  exports.useMouse = useMouse;
  exports.useMultiSelectableList = useMultiSelectableList;
  exports.useMutationObserver = useMutationObserver;
  exports.useMutationObserverRef = useMutationObserverRef;
  exports.useNavigatorLanguage = useNavigatorLanguage;
  exports.useOnWindowResize = useOnWindowResize;
  exports.useOnWindowScroll = useOnWindowScroll;
  exports.useOnline = useOnline;
  exports.useOutsideClick = useOutsideClick;
  exports.useOutsideClickRef = useOutsideClickRef;
  exports.usePrevious = usePrevious;
  exports.usePreviousDifferent = usePreviousDifferent;
  exports.usePreviousImmediate = usePreviousImmediate;
  exports.useQueueState = useQueueState;
  exports.useRaf = useRaf;
  exports.useSelect = useSelect;
  exports.useSelectableList = useSelectableList;
  exports.useSessionstorage = useSessionstorage;
  exports.useSessionstorageState = useSessionstorageState;
  exports.useStackState = useStackState;
  exports.useThrottle = useThrottle;
  exports.useTimeAgo = useTimeAgo;
  exports.useTimeout = useTimeout;
  exports.useTimeoutWhen = useTimeoutWhen;
  exports.useToggle = useToggle;
  exports.useUndoState = useUndoState;
  exports.useUpdateEffect = useUpdateEffect;
  exports.useVisibilitySensor = useVisibilitySensor;
  exports.useWillUnmount = useWillUnmount;
  exports.useWindowEventListener = useWindowEventListener;
  exports.useWindowScrollPosition = useWindowScrollPosition;
  exports.useWindowSize = useWindowSize;
  exports.useWorker = useWorker;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=rooks.js.map
